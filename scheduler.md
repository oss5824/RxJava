# 스케줄러
## 스케줄러
+ 싱글
  - 싱글 스케줄러는 Schedulers.single()을 호출해 만들 수 있음
  - 단일 스레드에 의해 뒷받침 되는 코드이기 때문에 항상 해당 스레드에서만 실행됨
  - 필요한 경우 매우느레드 대신 사용할 수 있지만 일반적으로 사용하려는 경우는 거의 없음

+ 트램펄린
  - 현재 스레드에서 코드를 실행하는 스케줄러로 작동방식은 현재 스레드의 큐에 실행될 코드 블록을 추가하는 식
  - .observerOn() 및 subscribeOn()에서 사용하는 경우 옵저버블의 기본 동작을 변경하지 않음
  - 커스텀 옵저버블을 만들 때 주로 고급 사용을 위해 예약됨

+ 뉴스레드
  - 뉴스레드는 Schedulers.newThread()를 호출해 만들 수 있고 각 옵저버블이 활성 상태가 되면 새 스레드를 만듦
  - 기본적으로 현재스레드에서 계ㅏ능ㄹ 오프로드가 필요할 때마다 어디에서나 사용 가능
  - 옵저버블마다 새로운 스레드를 생성하는 것은 스레드 생성이 비교적 무거운 연산이며 계산 오프로드에 더 적합한 다른 스케줄러가 있으므로 장기적으로 비용이 많이 들게 됨
  - 이 스케줄러는 스레드 생성 수에 제한을 두지 않음

+ IO
  - 가장 자주 사용하는 스케줄러
  - Subscribers.io()를 호출해 만들 수 있고 네트워크 요청,파일시스템 접근,안드로이드의 콘텐트 리졸버와 같은 IO관련 작업 부하에 적합
  - 워커 풀(worker pool)은 IO 스케줄러를 뒷받침
  - 초기에 풀은 한 워커로 시작하고 사용가능할 때 다른 옵저버 간에 재사용 됨(풀에 워커가 남아있지 않다면 새로운 워커가 생성되고 워커가 실행을 끝 마치면 다른 실행을 위해 다시 사용가능한 상태가 됨)
  - 시스템은 워커를 매번 재생성하지 않고 재사용함으로 리소스를 절약할 수 있음
  - 일반적으로 매우 편리하고 견고한 스케줄러이며 IO작업이 관련되 거의 모든 경우에 사용할 수 있음 
  - 풀의 크기에 제한이 없고 무제한 옵저버블이 생성될 가능성이 있기 때문에 주의 해야함(사용하지 않은 워커는 60초 후에 제거됨)

+ 컴퓨테이션
  - 워커 풀에 의해 지원된다는 점에서 IO스케줄러와 비슷
  - 컴퓨테이션 스케줄러의 풀 크기는 시스템에서 사용할 수 있는 코어 수로 고정 됨(사용 가능한 워커 수가 고정되어 있어서 프로세스 수보다 많은 작업이 실행되어야 하면 워커를 다시 사용할 수 있을 때까지 기다려야 함)
  - 이 스케줄러는 워커가 적어 워커의 부족에 영향을 많이 받기 때문에 IO기반작업이나 네트워크 요청에 적합하지 않음
  - 상대적으로 빠르게 계산되고 메인 스레드에서 완료해야 할 때 매우 적합

+ 이그제큐터 스케줄러
  - Executors 클래스로 생성된 커스텀 풀을 사용하기 위해 만들어짐
  - 옵저버블을 많이 만들 가능성이 있는 경우 IO 스케줄러를 대체할 수 있는 제한된 워커 풀을 만드는 데 사용

+ 안드로이드 스케줄러
  - AndroidSchedulers.mainThread()와 같이 사용하고 목적은 코드의 실행을 안드로이드의 메인 스레드로 되돌려 보내는 것임
  - 항상 계산이 다른 스케줄러로 오프로드 된 경우 사용해야 하며 리턴된 결과는 UI에 표시 되어야 함
  - 대부분 UI수정이 처리되는 주된 장소는 subscribeOn() 블록이므로 observeOn()호출에서 사용  

## 스케줄러 사용
+ subscribOn
  - subscribeOn()은 원천(source)옵저버블이 아이템을 방출하기로 돼 있는 스케줄러(스레드)를 수정
  - 기본적으로 모든 데이터의 처리가 시작되는 스레드를 수정
  - 옵저버블이 동작을 시작할 때의 스케줄러만 바꿈

+ observeOn
  - observeOn()이 호출될 때마다 코드가 실행되는 아래쪽 스레드가 변경 됨

+ observeOn 및 subscribeOn을 사용하는 두가지 규칙(경험으로부터 도출한 법칙이라고 함-필수는 아님)
  - 옵저버블의 흐름에 가능한 앞쪽에 subscribeOn을 배치하면 어떤 스케줄러가 구독을 시작하는지 확인하는데 도움이 됨
  - subscribeOn바로 앞에 observeOn을 하나만 배치하는 경우 subscribe()액션이 어느 스케줄러에서 즉시 실행되는지 확인할 수 있음

 
